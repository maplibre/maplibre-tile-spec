// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TileSetMetadata {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(message, repeated, tag = "2")]
    pub feature_tables: ::prost::alloc::vec::Vec<FeatureTableSchema>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub attribution: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "6")]
    pub min_zoom: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub max_zoom: ::core::option::Option<i32>,
    /// order left, bottom, right, top in WGS84
    #[prost(double, repeated, tag = "8")]
    pub bounds: ::prost::alloc::vec::Vec<f64>,
    /// order longitude, latitude in WGS84
    #[prost(double, repeated, tag = "9")]
    pub center: ::prost::alloc::vec::Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureTableSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
}
/// Column are top-level types in the schema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// specifies if the values are optional in the column and a present stream should be used
    #[prost(bool, tag = "2")]
    pub nullable: bool,
    #[prost(enumeration = "ColumnScope", tag = "3")]
    pub column_scope: i32,
    #[prost(oneof = "column::Type", tags = "4, 5")]
    pub r#type: ::core::option::Option<column::Type>,
}
/// Nested message and enum types in `Column`.
pub mod column {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "4")]
        ScalarType(super::ScalarColumn),
        #[prost(message, tag = "5")]
        ComplexType(super::ComplexColumn),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScalarColumn {
    /// this belongs elsewhere, but is here for now
    #[prost(bool, tag = "1")]
    pub long_id: bool,
    #[prost(oneof = "scalar_column::Type", tags = "4, 5")]
    pub r#type: ::core::option::Option<scalar_column::Type>,
}
/// Nested message and enum types in `ScalarColumn`.
pub mod scalar_column {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "super::ScalarType", tag = "4")]
        PhysicalType(i32),
        #[prost(enumeration = "super::LogicalScalarType", tag = "5")]
        LogicalType(i32),
    }
}
/// The type tree is flattened in to a list via a pre-order traversal
/// Represents a column if it is a root (top-level) type or a child of a nested type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComplexColumn {
    /// The complex type Geometry and the logical type BINARY have no children since there layout is implicit known.
    /// RangeMap has only one child specifying the type of the value since the key is always a vec2<double>.
    #[prost(message, repeated, tag = "6")]
    pub children: ::prost::alloc::vec::Vec<Field>,
    #[prost(oneof = "complex_column::Type", tags = "4, 5")]
    pub r#type: ::core::option::Option<complex_column::Type>,
}
/// Nested message and enum types in `ComplexColumn`.
pub mod complex_column {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "super::ComplexType", tag = "4")]
        PhysicalType(i32),
        #[prost(enumeration = "super::LogicalComplexType", tag = "5")]
        LogicalType(i32),
    }
}
/// Fields define nested or leaf types in the schema as part of a complex type definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    /// name and nullable are only needed in combination with a struct not for vec, list and map
    /// Map -> has the order key type, value type
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub nullable: ::core::option::Option<bool>,
    #[prost(oneof = "field::Type", tags = "3, 4")]
    pub r#type: ::core::option::Option<field::Type>,
}
/// Nested message and enum types in `Field`.
pub mod field {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "3")]
        ScalarField(super::ScalarField),
        #[prost(message, tag = "4")]
        ComplexField(super::ComplexField),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScalarField {
    #[prost(oneof = "scalar_field::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<scalar_field::Type>,
}
/// Nested message and enum types in `ScalarField`.
pub mod scalar_field {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "super::ScalarType", tag = "1")]
        PhysicalType(i32),
        #[prost(enumeration = "super::LogicalScalarType", tag = "2")]
        LogicalType(i32),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComplexField {
    #[prost(message, repeated, tag = "3")]
    pub children: ::prost::alloc::vec::Vec<Field>,
    #[prost(oneof = "complex_field::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<complex_field::Type>,
}
/// Nested message and enum types in `ComplexField`.
pub mod complex_field {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "super::ComplexType", tag = "1")]
        PhysicalType(i32),
        #[prost(enumeration = "super::LogicalComplexType", tag = "2")]
        LogicalType(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnScope {
    /// 1:1 Mapping of property and feature -> id and geometry
    Feature = 0,
    /// For M-Values -> 1:1 Mapping for property and vertex
    Vertex = 1,
}
impl ColumnScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Feature => "FEATURE",
            Self::Vertex => "VERTEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FEATURE" => Some(Self::Feature),
            "VERTEX" => Some(Self::Vertex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScalarType {
    Boolean = 0,
    Int8 = 1,
    Uint8 = 2,
    Int32 = 3,
    Uint32 = 4,
    Int64 = 5,
    Uint64 = 6,
    Float = 7,
    Double = 8,
    String = 9,
}
impl ScalarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Boolean => "BOOLEAN",
            Self::Int8 => "INT_8",
            Self::Uint8 => "UINT_8",
            Self::Int32 => "INT_32",
            Self::Uint32 => "UINT_32",
            Self::Int64 => "INT_64",
            Self::Uint64 => "UINT_64",
            Self::Float => "FLOAT",
            Self::Double => "DOUBLE",
            Self::String => "STRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOOLEAN" => Some(Self::Boolean),
            "INT_8" => Some(Self::Int8),
            "UINT_8" => Some(Self::Uint8),
            "INT_32" => Some(Self::Int32),
            "UINT_32" => Some(Self::Uint32),
            "INT_64" => Some(Self::Int64),
            "UINT_64" => Some(Self::Uint64),
            "FLOAT" => Some(Self::Float),
            "DOUBLE" => Some(Self::Double),
            "STRING" => Some(Self::String),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComplexType {
    Geometry = 0,
    Struct = 1,
}
impl ComplexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Geometry => "GEOMETRY",
            Self::Struct => "STRUCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GEOMETRY" => Some(Self::Geometry),
            "STRUCT" => Some(Self::Struct),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalScalarType {
    Id = 0,
}
impl LogicalScalarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Id => "ID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ID" => Some(Self::Id),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogicalComplexType {
    /// physical type: list<UInt8>
    Binary = 0,
    /// physical type: map<vec2<double, T>> -> special data structure which can be used for a efficient representation of linear referencing
    RangeMap = 1,
}
impl LogicalComplexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Binary => "BINARY",
            Self::RangeMap => "RANGE_MAP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BINARY" => Some(Self::Binary),
            "RANGE_MAP" => Some(Self::RangeMap),
            _ => None,
        }
    }
}
